/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Access,
  Access$inboundSchema,
  Access$Outbound,
  Access$outboundSchema,
} from "./access.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  FlagConfigEvaluation,
  FlagConfigEvaluation$inboundSchema,
  FlagConfigEvaluation$Outbound,
  FlagConfigEvaluation$outboundSchema,
} from "./flagconfigevaluation.js";
import {
  FlagConfigMigrationSettingsRep,
  FlagConfigMigrationSettingsRep$inboundSchema,
  FlagConfigMigrationSettingsRep$Outbound,
  FlagConfigMigrationSettingsRep$outboundSchema,
} from "./flagconfigmigrationsettingsrep.js";
import {
  FlagSummary,
  FlagSummary$inboundSchema,
  FlagSummary$Outbound,
  FlagSummary$outboundSchema,
} from "./flagsummary.js";
import {
  Link,
  Link$inboundSchema,
  Link$Outbound,
  Link$outboundSchema,
} from "./link.js";
import {
  Prerequisite,
  Prerequisite$inboundSchema,
  Prerequisite$Outbound,
  Prerequisite$outboundSchema,
} from "./prerequisite.js";
import {
  Rule,
  Rule$inboundSchema,
  Rule$Outbound,
  Rule$outboundSchema,
} from "./rule.js";
import {
  Target,
  Target$inboundSchema,
  Target$Outbound,
  Target$outboundSchema,
} from "./target.js";
import {
  VariationOrRolloutRep,
  VariationOrRolloutRep$inboundSchema,
  VariationOrRolloutRep$Outbound,
  VariationOrRolloutRep$outboundSchema,
} from "./variationorrolloutrep.js";

export type FeatureFlagConfig = {
  /**
   * Whether the flag is on
   */
  on: boolean;
  /**
   * Boolean indicating if the feature flag is archived
   */
  archived: boolean;
  salt: string;
  sel: string;
  lastModified: number;
  /**
   * Version of the feature flag
   */
  version: number;
  /**
   * An array of the individual targets that will receive a specific variation based on their key. Individual targets with a context kind of 'user' are included here.
   */
  targets?: Array<Target> | undefined;
  /**
   * An array of the individual targets that will receive a specific variation based on their key. Individual targets with context kinds other than 'user' are included here.
   */
  contextTargets?: Array<Target> | undefined;
  /**
   * An array of the rules for how to serve a variation to specific targets based on their attributes
   */
  rules?: Array<Rule> | undefined;
  fallthrough?: VariationOrRolloutRep | undefined;
  /**
   * The ID of the variation to serve when the flag is off
   */
  offVariation?: number | undefined;
  /**
   * An array of the prerequisite flags and their variations that are required before this flag takes effect
   */
  prerequisites?: Array<Prerequisite> | undefined;
  site: Link;
  access?: Access | undefined;
  /**
   * The environment name
   */
  environmentName: string;
  /**
   * Whether LaunchDarkly tracks events for the feature flag, for all rules
   */
  trackEvents: boolean;
  /**
   * Whether LaunchDarkly tracks events for the feature flag, for the default rule
   */
  trackEventsFallthrough: boolean;
  debugEventsUntilDate?: number | undefined;
  summary?: FlagSummary | undefined;
  evaluation?: FlagConfigEvaluation | undefined;
  migrationSettings?: FlagConfigMigrationSettingsRep | undefined;
};

/** @internal */
export const FeatureFlagConfig$inboundSchema: z.ZodType<
  FeatureFlagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  on: z.boolean(),
  archived: z.boolean(),
  salt: z.string(),
  sel: z.string(),
  lastModified: z.number().int(),
  version: z.number().int(),
  targets: z.array(Target$inboundSchema).optional(),
  contextTargets: z.array(Target$inboundSchema).optional(),
  rules: z.array(Rule$inboundSchema).optional(),
  fallthrough: VariationOrRolloutRep$inboundSchema.optional(),
  offVariation: z.number().int().optional(),
  prerequisites: z.array(Prerequisite$inboundSchema).optional(),
  _site: Link$inboundSchema,
  _access: Access$inboundSchema.optional(),
  _environmentName: z.string(),
  trackEvents: z.boolean(),
  trackEventsFallthrough: z.boolean(),
  _debugEventsUntilDate: z.number().int().optional(),
  _summary: FlagSummary$inboundSchema.optional(),
  evaluation: FlagConfigEvaluation$inboundSchema.optional(),
  migrationSettings: FlagConfigMigrationSettingsRep$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "_site": "site",
    "_access": "access",
    "_environmentName": "environmentName",
    "_debugEventsUntilDate": "debugEventsUntilDate",
    "_summary": "summary",
  });
});

/** @internal */
export type FeatureFlagConfig$Outbound = {
  on: boolean;
  archived: boolean;
  salt: string;
  sel: string;
  lastModified: number;
  version: number;
  targets?: Array<Target$Outbound> | undefined;
  contextTargets?: Array<Target$Outbound> | undefined;
  rules?: Array<Rule$Outbound> | undefined;
  fallthrough?: VariationOrRolloutRep$Outbound | undefined;
  offVariation?: number | undefined;
  prerequisites?: Array<Prerequisite$Outbound> | undefined;
  _site: Link$Outbound;
  _access?: Access$Outbound | undefined;
  _environmentName: string;
  trackEvents: boolean;
  trackEventsFallthrough: boolean;
  _debugEventsUntilDate?: number | undefined;
  _summary?: FlagSummary$Outbound | undefined;
  evaluation?: FlagConfigEvaluation$Outbound | undefined;
  migrationSettings?: FlagConfigMigrationSettingsRep$Outbound | undefined;
};

/** @internal */
export const FeatureFlagConfig$outboundSchema: z.ZodType<
  FeatureFlagConfig$Outbound,
  z.ZodTypeDef,
  FeatureFlagConfig
> = z.object({
  on: z.boolean(),
  archived: z.boolean(),
  salt: z.string(),
  sel: z.string(),
  lastModified: z.number().int(),
  version: z.number().int(),
  targets: z.array(Target$outboundSchema).optional(),
  contextTargets: z.array(Target$outboundSchema).optional(),
  rules: z.array(Rule$outboundSchema).optional(),
  fallthrough: VariationOrRolloutRep$outboundSchema.optional(),
  offVariation: z.number().int().optional(),
  prerequisites: z.array(Prerequisite$outboundSchema).optional(),
  site: Link$outboundSchema,
  access: Access$outboundSchema.optional(),
  environmentName: z.string(),
  trackEvents: z.boolean(),
  trackEventsFallthrough: z.boolean(),
  debugEventsUntilDate: z.number().int().optional(),
  summary: FlagSummary$outboundSchema.optional(),
  evaluation: FlagConfigEvaluation$outboundSchema.optional(),
  migrationSettings: FlagConfigMigrationSettingsRep$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    site: "_site",
    access: "_access",
    environmentName: "_environmentName",
    debugEventsUntilDate: "_debugEventsUntilDate",
    summary: "_summary",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FeatureFlagConfig$ {
  /** @deprecated use `FeatureFlagConfig$inboundSchema` instead. */
  export const inboundSchema = FeatureFlagConfig$inboundSchema;
  /** @deprecated use `FeatureFlagConfig$outboundSchema` instead. */
  export const outboundSchema = FeatureFlagConfig$outboundSchema;
  /** @deprecated use `FeatureFlagConfig$Outbound` instead. */
  export type Outbound = FeatureFlagConfig$Outbound;
}

export function featureFlagConfigToJSON(
  featureFlagConfig: FeatureFlagConfig,
): string {
  return JSON.stringify(
    FeatureFlagConfig$outboundSchema.parse(featureFlagConfig),
  );
}

export function featureFlagConfigFromJSON(
  jsonString: string,
): SafeParseResult<FeatureFlagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeatureFlagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeatureFlagConfig' from JSON`,
  );
}
