/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type User = {
  /**
   * The user key. This is the only mandatory user attribute.
   */
  key?: string | undefined;
  /**
   * If provided, used with the user key to generate a variation in percentage rollouts
   */
  secondary?: string | undefined;
  /**
   * The user's IP address
   */
  ip?: string | undefined;
  /**
   * The user's country
   */
  country?: string | undefined;
  /**
   * The user's email
   */
  email?: string | undefined;
  /**
   * The user's first name
   */
  firstName?: string | undefined;
  /**
   * The user's last name
   */
  lastName?: string | undefined;
  /**
   * An absolute URL to an avatar image.
   */
  avatar?: string | undefined;
  /**
   * The user's full name
   */
  name?: string | undefined;
  /**
   * Whether the user is anonymous. If true, this user does not appear on the Contexts list in the LaunchDarkly user interface.
   */
  anonymous?: boolean | undefined;
  /**
   * Any other custom attributes for this user. Custom attributes contain any other user data that you would like to use to conditionally target your users.
   */
  custom?: { [k: string]: any } | undefined;
  /**
   * A list of attribute names that are marked as private. You can use these attributes in targeting rules and segments. If you are using a server-side SDK, the SDK will not send the private attribute back to LaunchDarkly. If you are using a client-side SDK, the SDK will send the private attribute back to LaunchDarkly for evaluation. However, the SDK won't send the attribute to LaunchDarkly in events data, LaunchDarkly won't store the private attribute, and the private attribute will not appear on the Contexts list.
   */
  privateAttrs?: Array<string> | undefined;
};

/** @internal */
export const User$inboundSchema: z.ZodType<User, z.ZodTypeDef, unknown> = z
  .object({
    key: z.string().optional(),
    secondary: z.string().optional(),
    ip: z.string().optional(),
    country: z.string().optional(),
    email: z.string().optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().optional(),
    name: z.string().optional(),
    anonymous: z.boolean().optional(),
    custom: z.record(z.any()).optional(),
    privateAttrs: z.array(z.string()).optional(),
  });

/** @internal */
export type User$Outbound = {
  key?: string | undefined;
  secondary?: string | undefined;
  ip?: string | undefined;
  country?: string | undefined;
  email?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  avatar?: string | undefined;
  name?: string | undefined;
  anonymous?: boolean | undefined;
  custom?: { [k: string]: any } | undefined;
  privateAttrs?: Array<string> | undefined;
};

/** @internal */
export const User$outboundSchema: z.ZodType<User$Outbound, z.ZodTypeDef, User> =
  z.object({
    key: z.string().optional(),
    secondary: z.string().optional(),
    ip: z.string().optional(),
    country: z.string().optional(),
    email: z.string().optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    avatar: z.string().optional(),
    name: z.string().optional(),
    anonymous: z.boolean().optional(),
    custom: z.record(z.any()).optional(),
    privateAttrs: z.array(z.string()).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace User$ {
  /** @deprecated use `User$inboundSchema` instead. */
  export const inboundSchema = User$inboundSchema;
  /** @deprecated use `User$outboundSchema` instead. */
  export const outboundSchema = User$outboundSchema;
  /** @deprecated use `User$Outbound` instead. */
  export type Outbound = User$Outbound;
}

export function userToJSON(user: User): string {
  return JSON.stringify(User$outboundSchema.parse(user));
}

export function userFromJSON(
  jsonString: string,
): SafeParseResult<User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'User' from JSON`,
  );
}
