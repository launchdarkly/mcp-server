/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  IntegrationMetadata,
  IntegrationMetadata$inboundSchema,
  IntegrationMetadata$Outbound,
  IntegrationMetadata$outboundSchema,
} from "./integrationmetadata.js";
import {
  LastSeenMetadata,
  LastSeenMetadata$inboundSchema,
  LastSeenMetadata$Outbound,
  LastSeenMetadata$outboundSchema,
} from "./lastseenmetadata.js";
import {
  Link,
  Link$inboundSchema,
  Link$Outbound,
  Link$outboundSchema,
} from "./link.js";
import {
  MemberPermissionGrantSummaryRep,
  MemberPermissionGrantSummaryRep$inboundSchema,
  MemberPermissionGrantSummaryRep$Outbound,
  MemberPermissionGrantSummaryRep$outboundSchema,
} from "./memberpermissiongrantsummaryrep.js";
import {
  MemberTeamSummaryRep,
  MemberTeamSummaryRep$inboundSchema,
  MemberTeamSummaryRep$Outbound,
  MemberTeamSummaryRep$outboundSchema,
} from "./memberteamsummaryrep.js";

export type Member = {
  /**
   * The location and content type of related resources
   */
  links: { [k: string]: Link };
  /**
   * The member's ID
   */
  id: string;
  /**
   * The member's first name
   */
  firstName?: string | undefined;
  /**
   * The member's last name
   */
  lastName?: string | undefined;
  /**
   * The member's built-in role. If the member has no custom roles, this role will be in effect.
   */
  role: string;
  /**
   * The member's email address
   */
  email: string;
  /**
   * Whether the member has a pending invitation
   */
  pendingInvite: boolean;
  /**
   * Whether the member's email address has been verified
   */
  verified: boolean;
  /**
   * The member's email address before it has been verified, for accounts where email verification is required
   */
  pendingEmail?: string | undefined;
  /**
   * The set of custom roles (as keys) assigned to the member
   */
  customRoles: Array<string>;
  /**
   * Whether multi-factor authentication is enabled for this member
   */
  mfa: string;
  /**
   * Default dashboards that the member has chosen to ignore
   */
  excludedDashboards?: Array<string> | undefined;
  lastSeen: number;
  lastSeenMetadata?: LastSeenMetadata | undefined;
  integrationMetadata?: IntegrationMetadata | undefined;
  /**
   * Details on the teams this member is assigned to
   */
  teams?: Array<MemberTeamSummaryRep> | undefined;
  /**
   * A list of permission grants. Permission grants allow a member to have access to a specific action, without having to create or update a custom role.
   */
  permissionGrants?: Array<MemberPermissionGrantSummaryRep> | undefined;
  creationDate: number;
  /**
   * A list of OAuth providers
   */
  oauthProviders?: Array<string> | undefined;
  /**
   * Version of the current configuration
   */
  version?: number | undefined;
  roleAttributes?: { [k: string]: Array<string> } | undefined;
};

/** @internal */
export const Member$inboundSchema: z.ZodType<Member, z.ZodTypeDef, unknown> = z
  .object({
    _links: z.record(Link$inboundSchema),
    _id: z.string(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    role: z.string(),
    email: z.string(),
    _pendingInvite: z.boolean(),
    _verified: z.boolean(),
    _pendingEmail: z.string().optional(),
    customRoles: z.array(z.string()),
    mfa: z.string(),
    excludedDashboards: z.array(z.string()).optional(),
    _lastSeen: z.number().int(),
    _lastSeenMetadata: LastSeenMetadata$inboundSchema.optional(),
    _integrationMetadata: IntegrationMetadata$inboundSchema.optional(),
    teams: z.array(MemberTeamSummaryRep$inboundSchema).optional(),
    permissionGrants: z.array(MemberPermissionGrantSummaryRep$inboundSchema)
      .optional(),
    creationDate: z.number().int(),
    oauthProviders: z.array(z.string()).optional(),
    version: z.number().int().optional(),
    roleAttributes: z.record(z.array(z.string())).optional(),
  }).transform((v) => {
    return remap$(v, {
      "_links": "links",
      "_id": "id",
      "_pendingInvite": "pendingInvite",
      "_verified": "verified",
      "_pendingEmail": "pendingEmail",
      "_lastSeen": "lastSeen",
      "_lastSeenMetadata": "lastSeenMetadata",
      "_integrationMetadata": "integrationMetadata",
    });
  });

/** @internal */
export type Member$Outbound = {
  _links: { [k: string]: Link$Outbound };
  _id: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  role: string;
  email: string;
  _pendingInvite: boolean;
  _verified: boolean;
  _pendingEmail?: string | undefined;
  customRoles: Array<string>;
  mfa: string;
  excludedDashboards?: Array<string> | undefined;
  _lastSeen: number;
  _lastSeenMetadata?: LastSeenMetadata$Outbound | undefined;
  _integrationMetadata?: IntegrationMetadata$Outbound | undefined;
  teams?: Array<MemberTeamSummaryRep$Outbound> | undefined;
  permissionGrants?:
    | Array<MemberPermissionGrantSummaryRep$Outbound>
    | undefined;
  creationDate: number;
  oauthProviders?: Array<string> | undefined;
  version?: number | undefined;
  roleAttributes?: { [k: string]: Array<string> } | undefined;
};

/** @internal */
export const Member$outboundSchema: z.ZodType<
  Member$Outbound,
  z.ZodTypeDef,
  Member
> = z.object({
  links: z.record(Link$outboundSchema),
  id: z.string(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  role: z.string(),
  email: z.string(),
  pendingInvite: z.boolean(),
  verified: z.boolean(),
  pendingEmail: z.string().optional(),
  customRoles: z.array(z.string()),
  mfa: z.string(),
  excludedDashboards: z.array(z.string()).optional(),
  lastSeen: z.number().int(),
  lastSeenMetadata: LastSeenMetadata$outboundSchema.optional(),
  integrationMetadata: IntegrationMetadata$outboundSchema.optional(),
  teams: z.array(MemberTeamSummaryRep$outboundSchema).optional(),
  permissionGrants: z.array(MemberPermissionGrantSummaryRep$outboundSchema)
    .optional(),
  creationDate: z.number().int(),
  oauthProviders: z.array(z.string()).optional(),
  version: z.number().int().optional(),
  roleAttributes: z.record(z.array(z.string())).optional(),
}).transform((v) => {
  return remap$(v, {
    links: "_links",
    id: "_id",
    pendingInvite: "_pendingInvite",
    verified: "_verified",
    pendingEmail: "_pendingEmail",
    lastSeen: "_lastSeen",
    lastSeenMetadata: "_lastSeenMetadata",
    integrationMetadata: "_integrationMetadata",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Member$ {
  /** @deprecated use `Member$inboundSchema` instead. */
  export const inboundSchema = Member$inboundSchema;
  /** @deprecated use `Member$outboundSchema` instead. */
  export const outboundSchema = Member$outboundSchema;
  /** @deprecated use `Member$Outbound` instead. */
  export type Outbound = Member$Outbound;
}

export function memberToJSON(member: Member): string {
  return JSON.stringify(Member$outboundSchema.parse(member));
}

export function memberFromJSON(
  jsonString: string,
): SafeParseResult<Member, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Member$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Member' from JSON`,
  );
}
