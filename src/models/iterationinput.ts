/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  FlagInput,
  FlagInput$inboundSchema,
  FlagInput$Outbound,
  FlagInput$outboundSchema,
} from "./flaginput.js";
import {
  MetricInput,
  MetricInput$inboundSchema,
  MetricInput$Outbound,
  MetricInput$outboundSchema,
} from "./metricinput.js";
import {
  TreatmentInput,
  TreatmentInput$inboundSchema,
  TreatmentInput$Outbound,
  TreatmentInput$outboundSchema,
} from "./treatmentinput.js";

export type IterationInput = {
  /**
   * The expected outcome of this experiment
   */
  hypothesis: string;
  /**
   * Whether to allow the experiment to reassign traffic to different variations when you increase or decrease the traffic in your experiment audience (true) or keep all traffic assigned to its initial variation (false). Defaults to true.
   */
  canReshuffleTraffic?: boolean | undefined;
  metrics: Array<MetricInput>;
  /**
   * The key of the primary metric for this experiment. Either <code>primarySingleMetricKey</code> or <code>primaryFunnelKey</code> must be present.
   */
  primarySingleMetricKey?: string | undefined;
  /**
   * The key of the primary funnel group for this experiment. Either <code>primarySingleMetricKey</code> or <code>primaryFunnelKey</code> must be present.
   */
  primaryFunnelKey?: string | undefined;
  treatments: Array<TreatmentInput>;
  flags: { [k: string]: FlagInput };
  /**
   * The unit of randomization for this iteration. Defaults to user.
   */
  randomizationUnit?: string | undefined;
  /**
   * The attributes that this iteration's results can be sliced by
   */
  attributes?: Array<string> | undefined;
};

/** @internal */
export const IterationInput$inboundSchema: z.ZodType<
  IterationInput,
  z.ZodTypeDef,
  unknown
> = z.object({
  hypothesis: z.string(),
  canReshuffleTraffic: z.boolean().optional(),
  metrics: z.array(MetricInput$inboundSchema),
  primarySingleMetricKey: z.string().optional(),
  primaryFunnelKey: z.string().optional(),
  treatments: z.array(TreatmentInput$inboundSchema),
  flags: z.record(FlagInput$inboundSchema),
  randomizationUnit: z.string().optional(),
  attributes: z.array(z.string()).optional(),
});

/** @internal */
export type IterationInput$Outbound = {
  hypothesis: string;
  canReshuffleTraffic?: boolean | undefined;
  metrics: Array<MetricInput$Outbound>;
  primarySingleMetricKey?: string | undefined;
  primaryFunnelKey?: string | undefined;
  treatments: Array<TreatmentInput$Outbound>;
  flags: { [k: string]: FlagInput$Outbound };
  randomizationUnit?: string | undefined;
  attributes?: Array<string> | undefined;
};

/** @internal */
export const IterationInput$outboundSchema: z.ZodType<
  IterationInput$Outbound,
  z.ZodTypeDef,
  IterationInput
> = z.object({
  hypothesis: z.string(),
  canReshuffleTraffic: z.boolean().optional(),
  metrics: z.array(MetricInput$outboundSchema),
  primarySingleMetricKey: z.string().optional(),
  primaryFunnelKey: z.string().optional(),
  treatments: z.array(TreatmentInput$outboundSchema),
  flags: z.record(FlagInput$outboundSchema),
  randomizationUnit: z.string().optional(),
  attributes: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace IterationInput$ {
  /** @deprecated use `IterationInput$inboundSchema` instead. */
  export const inboundSchema = IterationInput$inboundSchema;
  /** @deprecated use `IterationInput$outboundSchema` instead. */
  export const outboundSchema = IterationInput$outboundSchema;
  /** @deprecated use `IterationInput$Outbound` instead. */
  export type Outbound = IterationInput$Outbound;
}

export function iterationInputToJSON(iterationInput: IterationInput): string {
  return JSON.stringify(IterationInput$outboundSchema.parse(iterationInput));
}

export function iterationInputFromJSON(
  jsonString: string,
): SafeParseResult<IterationInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IterationInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IterationInput' from JSON`,
  );
}
