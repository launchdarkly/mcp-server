/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { LaunchdarklyMcpServerCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update expiring user target for flags
 *
 * @remarks
 * Schedule the specified user for removal from individual targeting on one or more flags. The user must already be individually targeted for each flag.
 *
 * You can add, update, or remove a scheduled removal date. You can only schedule a user for removal on a single variation per flag.
 *
 * Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](https://launchdarkly.com/docs/api#updates-using-semantic-patch).
 *
 * ### Instructions
 *
 * Semantic patch requests support the following `kind` instructions for updating expiring user targets.
 *
 * <details>
 * <summary>Click to expand instructions for <strong>updating expiring user targets</strong></summary>
 *
 * #### addExpireUserTargetDate
 *
 * Adds a date and time that LaunchDarkly will remove the user from the flag's individual targeting.
 *
 * ##### Parameters
 *
 * * `flagKey`: The flag key
 * * `variationId`: ID of a variation on the flag
 * * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.
 *
 * #### updateExpireUserTargetDate
 *
 * Updates the date and time that LaunchDarkly will remove the user from the flag's individual targeting.
 *
 * ##### Parameters
 *
 * * `flagKey`: The flag key
 * * `variationId`: ID of a variation on the flag
 * * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the user from individual targeting for this flag.
 * * `version`: The version of the expiring user target to update. If included, update will fail if version doesn't match current version of the expiring user target.
 *
 * #### removeExpireUserTargetDate
 *
 * Removes the scheduled removal of the user from the flag's individual targeting. The user will remain part of the flag's individual targeting until explicitly removed, or until another removal is scheduled.
 *
 * ##### Parameters
 *
 * * `flagKey`: The flag key
 * * `variationId`: ID of a variation on the flag
 *
 * </details>
 *
 * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export function userSettingsPatchExpiringFlagsForUser(
  client: LaunchdarklyMcpServerCore,
  request: operations.PatchExpiringFlagsForUserRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.ExpiringUserTargetPatchResponse,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: LaunchdarklyMcpServerCore,
  request: operations.PatchExpiringFlagsForUserRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.ExpiringUserTargetPatchResponse,
      | errors.InvalidRequestErrorRep
      | errors.UnauthorizedErrorRep
      | errors.ForbiddenErrorRep
      | errors.NotFoundErrorRep
      | errors.RateLimitedErrorRep
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.PatchExpiringFlagsForUserRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.patchUsersRequest, { explode: true });

  const pathParams = {
    environmentKey: encodeSimple("environmentKey", payload.environmentKey, {
      explode: false,
      charEncoding: "percent",
    }),
    projectKey: encodeSimple("projectKey", payload.projectKey, {
      explode: false,
      charEncoding: "percent",
    }),
    userKey: encodeSimple("userKey", payload.userKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/api/v2/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}",
  )(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "patchExpiringFlagsForUser",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.apiKey,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "429", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.ExpiringUserTargetPatchResponse,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, models.ExpiringUserTargetPatchResponse$inboundSchema),
    M.jsonErr(400, errors.InvalidRequestErrorRep$inboundSchema),
    M.jsonErr(401, errors.UnauthorizedErrorRep$inboundSchema),
    M.jsonErr(403, errors.ForbiddenErrorRep$inboundSchema),
    M.jsonErr(404, errors.NotFoundErrorRep$inboundSchema),
    M.jsonErr(429, errors.RateLimitedErrorRep$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
