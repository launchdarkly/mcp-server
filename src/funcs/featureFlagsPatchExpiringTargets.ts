/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { LaunchdarklyMcpServerCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update expiring context targets on feature flag
 *
 * @remarks
 * Schedule a context for removal from individual targeting on a feature flag. The flag must already individually target the context.
 *
 * You can add, update, or remove a scheduled removal date. You can only schedule a context for removal on a single variation per flag.
 *
 * Updating an expiring target uses the semantic patch format. To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](https://launchdarkly.com/docs/api#updates-using-semantic-patch).
 *
 * ### Instructions
 *
 * Semantic patch requests support the following `kind` instructions for updating expiring targets.
 *
 * <details>
 * <summary>Click to expand instructions for <strong>updating expiring targets</strong></summary>
 *
 * #### addExpiringTarget
 *
 * Adds a date and time that LaunchDarkly will remove the context from the flag's individual targeting.
 *
 * ##### Parameters
 *
 * * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag
 * * `variationId`: ID of a variation on the flag
 * * `contextKey`: The context key for the context to remove from individual targeting
 * * `contextKind`: The kind of context represented by the `contextKey`
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addExpiringTarget",
 *     "value": 1754006460000,
 *     "variationId": "4254742c-71ae-411f-a992-43b18a51afe0",
 *     "contextKey": "user-key-123abc",
 *     "contextKind": "user"
 *   }]
 * }
 * ```
 *
 * #### updateExpiringTarget
 *
 * Updates the date and time that LaunchDarkly will remove the context from the flag's individual targeting
 *
 * ##### Parameters
 *
 * * `value`: The time, in Unix milliseconds, when LaunchDarkly should remove the context from individual targeting for this flag
 * * `variationId`: ID of a variation on the flag
 * * `contextKey`: The context key for the context to remove from individual targeting
 * * `contextKind`: The kind of context represented by the `contextKey`
 * * `version`: (Optional) The version of the expiring target to update. If included, update will fail if version doesn't match current version of the expiring target.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "updateExpiringTarget",
 *     "value": 1754006460000,
 *     "variationId": "4254742c-71ae-411f-a992-43b18a51afe0",
 *     "contextKey": "user-key-123abc",
 *     "contextKind": "user"
 *   }]
 * }
 * ```
 *
 * #### removeExpiringTarget
 *
 * Removes the scheduled removal of the context from the flag's individual targeting. The context will remain part of the flag's individual targeting until you explicitly remove it, or until you schedule another removal.
 *
 * ##### Parameters
 *
 * * `variationId`: ID of a variation on the flag
 * * `contextKey`: The context key for the context to remove from individual targeting
 * * `contextKind`: The kind of context represented by the `contextKey`
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeExpiringTarget",
 *     "variationId": "4254742c-71ae-411f-a992-43b18a51afe0",
 *     "contextKey": "user-key-123abc",
 *     "contextKind": "user"
 *   }]
 * }
 * ```
 *
 * </details>
 */
export function featureFlagsPatchExpiringTargets(
  client: LaunchdarklyMcpServerCore,
  request: operations.PatchExpiringTargetsRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.ExpiringTargetPatchResponse,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: LaunchdarklyMcpServerCore,
  request: operations.PatchExpiringTargetsRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.ExpiringTargetPatchResponse,
      | errors.InvalidRequestErrorRep
      | errors.UnauthorizedErrorRep
      | errors.ForbiddenErrorRep
      | errors.NotFoundErrorRep
      | errors.RateLimitedErrorRep
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.PatchExpiringTargetsRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.patchFlagsRequest, { explode: true });

  const pathParams = {
    environmentKey: encodeSimple("environmentKey", payload.environmentKey, {
      explode: false,
      charEncoding: "percent",
    }),
    featureFlagKey: encodeSimple("featureFlagKey", payload.featureFlagKey, {
      explode: false,
      charEncoding: "percent",
    }),
    projectKey: encodeSimple("projectKey", payload.projectKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/api/v2/flags/{projectKey}/{featureFlagKey}/expiring-targets/{environmentKey}",
  )(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "patchExpiringTargets",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.apiKey,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "429", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.ExpiringTargetPatchResponse,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, models.ExpiringTargetPatchResponse$inboundSchema),
    M.jsonErr(400, errors.InvalidRequestErrorRep$inboundSchema),
    M.jsonErr(401, errors.UnauthorizedErrorRep$inboundSchema),
    M.jsonErr(403, errors.ForbiddenErrorRep$inboundSchema),
    M.jsonErr(404, errors.NotFoundErrorRep$inboundSchema),
    M.jsonErr(429, errors.RateLimitedErrorRep$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
