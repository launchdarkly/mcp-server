/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { LaunchdarklyMcpServerCore } from "../core.js";
import { encodeFormQuery, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Get stream usage by SDK version
 *
 * @remarks
 * Get multiple series of the number of streaming connections to LaunchDarkly in each time period, separated by SDK type and version. Information about each series is in the metadata array. The granularity of the data depends on the age of the data requested. If the requested range is within the past 2 hours, minutely data is returned. If it is within the last two days, hourly data is returned. Otherwise, daily data is returned.
 */
export function accountUsageBetaGetStreamUsageBySDKVersion(
  client: LaunchdarklyMcpServerCore,
  request: operations.GetStreamUsageBySDKVersionRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    models.SeriesListRep,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: LaunchdarklyMcpServerCore,
  request: operations.GetStreamUsageBySDKVersionRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      models.SeriesListRep,
      | errors.InvalidRequestErrorRep
      | errors.UnauthorizedErrorRep
      | errors.ForbiddenErrorRep
      | errors.NotFoundErrorRep
      | errors.RateLimitedErrorRep
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      operations.GetStreamUsageBySDKVersionRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const pathParams = {
    source: encodeSimple("source", payload.source, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/api/v2/usage/streams/{source}/bysdkversion")(
    pathParams,
  );

  const query = encodeFormQuery({
    "from": payload.from,
    "sdk": payload.sdk,
    "to": payload.to,
    "tz": payload.tz,
    "version": payload.version,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "getStreamUsageBySdkVersion",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.apiKey,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "429", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    models.SeriesListRep,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, models.SeriesListRep$inboundSchema),
    M.jsonErr(400, errors.InvalidRequestErrorRep$inboundSchema),
    M.jsonErr(401, errors.UnauthorizedErrorRep$inboundSchema),
    M.jsonErr(403, errors.ForbiddenErrorRep$inboundSchema),
    M.jsonErr(404, errors.NotFoundErrorRep$inboundSchema),
    M.jsonErr(429, errors.RateLimitedErrorRep$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
