/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { LaunchDarklyCore } from "../core.js";
import { encodeFormQuery, encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Update team
 *
 * @remarks
 * Perform a partial update to a team. Updating a team uses the semantic patch format.
 *
 * To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](https://launchdarkly.com/docs/api#updates-using-semantic-patch).
 *
 * ### Instructions
 *
 * Semantic patch requests support the following `kind` instructions for updating teams. Several of the instructions require one or more member IDs as parameters. The member ID is returned as part of the [List account members](https://launchdarkly.com/docs/ld-docs/api/account-members/get-members) response. It is the `_id` field of each element in the `items` array.
 *
 * <details>
 * <summary>Click to expand instructions for <strong>updating teams</strong></summary>
 *
 * #### addCustomRoles
 *
 * Adds custom roles to the team. Team members will have these custom roles granted to them.
 *
 * ##### Parameters
 *
 * - `values`: List of custom role keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addCustomRoles",
 *     "values": [ "example-custom-role" ]
 *   }]
 * }
 * ```
 *
 * #### addMembers
 *
 * Adds members to the team.
 *
 * ##### Parameters
 *
 * - `values`: List of member IDs to add.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addMembers",
 *     "values": [ "1234a56b7c89d012345e678f", "507f1f77bcf86cd799439011" ]
 *   }]
 * }
 * ```
 *
 * #### addPermissionGrants
 *
 * Adds permission grants to members for the team. For example, a permission grant could allow a member to act as a team maintainer. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The members do not have to be team members to have a permission grant for the team.
 *
 * ##### Parameters
 *
 * - `actionSet`: Name of the action set.
 * - `actions`: List of actions.
 * - `memberIDs`: List of member IDs.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addPermissionGrants",
 *     "actions": [ "updateTeamName", "updateTeamDescription" ],
 *     "memberIDs": [ "1234a56b7c89d012345e678f", "507f1f77bcf86cd799439011" ]
 *   }]
 * }
 * ```
 *
 * #### addRoleAttribute
 *
 * Adds a role attribute to a team. Team members will have these role attribute values scoped for all custom roles granted to them.
 *
 * ##### Parameters
 *
 * - `key`: The role attribute key to add.
 * - `values`: List of role attribute values for that key.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [
 *     {
 *       "kind": "addRoleAttribute",
 *       "key": "testAttribute",
 *       "values": ["someNewValue", "someOtherNewValue"]
 *     }
 *   ]
 * }
 * ```
 *
 * #### removeCustomRoles
 *
 * Removes custom roles from the team. The app will no longer grant these custom roles to the team members.
 *
 * ##### Parameters
 *
 * - `values`: List of custom role keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeCustomRoles",
 *     "values": [ "example-custom-role" ]
 *   }]
 * }
 * ```
 *
 * #### removeMembers
 *
 * Removes members from the team.
 *
 * ##### Parameters
 *
 * - `values`: List of member IDs to remove.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeMembers",
 *     "values": [ "1234a56b7c89d012345e678f", "507f1f77bcf86cd799439011" ]
 *   }]
 * }
 * ```
 *
 * #### removePermissionGrants
 *
 * Removes permission grants from members for the team. A permission grant may have either an `actionSet` or a list of `actions` but not both at the same time. The `actionSet` and `actions` must match an existing permission grant.
 *
 * ##### Parameters
 *
 * - `actionSet`: Name of the action set.
 * - `actions`: List of actions.
 * - `memberIDs`: List of member IDs.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removePermissionGrants",
 *     "actions": [ "updateTeamName", "updateTeamDescription" ],
 *     "memberIDs": [ "1234a56b7c89d012345e678f", "507f1f77bcf86cd799439011" ]
 *   }]
 * }
 * ```
 *
 * #### removeRoleAttribute
 *
 * Removes a role attribute from the team.
 *
 * ##### Parameters
 *
 * - `key`: The role attribute key to remove.
 *
 * Here's an example:
 * ```json
 * {
 *   "instructions": [
 *     {
 *       "kind": "removeRoleAttribute",
 *       "key": "testAttribute"
 *     }
 *   ]
 * }
 * ```
 *
 * #### replaceMembers
 *
 * Replaces the existing members of the team with the new members.
 *
 * ##### Parameters
 *
 * - `values`: List of member IDs of the new members.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "replaceMembers",
 *     "values": [ "1234a56b7c89d012345e678f", "507f1f77bcf86cd799439011" ]
 *   }]
 * }
 * ```
 *
 * #### replaceRoleAttributes
 *
 * Replaces the existing role attributes for the team with new role attributes.
 *
 * ##### Parameters
 *
 * - `values`: A map of role attribute keys to lists of role attribute values
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "replaceRoleAttributes",
 *     "values": {
 *       "testAttribute": [ "someNewValue", "someOtherNewValue" ],
 *       "projectRoleAttribute": [ "project1", "project2"]
 *     }
 *   }]
 * }
 * ```
 *
 * #### updateDescription
 *
 * Updates the description of the team.
 *
 * ##### Parameters
 *
 * - `value`: The new description.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "updateDescription",
 *     "value": "Updated team description"
 *   }]
 * }
 * ```
 *
 * #### updateName
 *
 * Updates the name of the team.
 *
 * ##### Parameters
 *
 * - `value`: The new name.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "updateName",
 *     "value": "Updated team name"
 *   }]
 * }
 * ```
 *
 * #### updateRoleAttribute
 *
 * Updates a role attribute on the team. Any existing values for the given key will be replaced with the new values. Team members will have these role attribute values scoped for all custom roles granted to them.
 *
 * ##### Parameters
 *
 * - `key`: The role attribute key to update.
 * - `values`: List of role attribute values for that key.
 *
 * Here's an example:
 * ```json
 * {
 *   "instructions": [
 *     {
 *       "kind": "updateRoleAttribute",
 *       "key": "testAttribute",
 *       "values": ["someNewValue", "someOtherNewValue"]
 *     }
 *   ]
 * }
 * ```
 *
 * </details>
 *
 * ### Expanding the teams response
 * LaunchDarkly supports four fields for expanding the "Update team" response. By default, these fields are **not** included in the response.
 *
 * To expand the response, append the `expand` query parameter and add a comma-separated list with any of the following fields:
 *
 * * `members` includes the total count of members that belong to the team.
 * * `roles` includes a paginated list of the custom roles that you have assigned to the team.
 * * `projects` includes a paginated list of the projects that the team has any write access to.
 * * `maintainers` includes a paginated list of the maintainers that you have assigned to the team.
 *
 * For example, `expand=members,roles` includes the `members` and `roles` fields in the response.
 */
export function teamsPatch(
  client: LaunchDarklyCore,
  request: operations.PatchTeamRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.Team,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.NotFoundErrorRep
    | errors.MethodNotAllowedErrorRep
    | errors.StatusConflictErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: LaunchDarklyCore,
  request: operations.PatchTeamRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.Team,
      | errors.InvalidRequestErrorRep
      | errors.UnauthorizedErrorRep
      | errors.NotFoundErrorRep
      | errors.MethodNotAllowedErrorRep
      | errors.StatusConflictErrorRep
      | errors.RateLimitedErrorRep
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.PatchTeamRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.teamPatchInput, { explode: true });

  const pathParams = {
    teamKey: encodeSimple("teamKey", payload.teamKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc("/api/v2/teams/{teamKey}")(pathParams);

  const query = encodeFormQuery({
    "expand": payload.expand,
  });

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "patchTeam",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.apiKey,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "404", "405", "409", "429", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    components.Team,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.NotFoundErrorRep
    | errors.MethodNotAllowedErrorRep
    | errors.StatusConflictErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, components.Team$inboundSchema),
    M.jsonErr(400, errors.InvalidRequestErrorRep$inboundSchema),
    M.jsonErr(401, errors.UnauthorizedErrorRep$inboundSchema),
    M.jsonErr(404, errors.NotFoundErrorRep$inboundSchema),
    M.jsonErr(405, errors.MethodNotAllowedErrorRep$inboundSchema),
    M.jsonErr(409, errors.StatusConflictErrorRep$inboundSchema),
    M.jsonErr(429, errors.RateLimitedErrorRep$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
