/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { LaunchDarklyCore } from "../core.js";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import * as components from "../models/components/index.js";
import { APIError } from "../models/errors/apierror.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/httpclienterrors.js";
import * as errors from "../models/errors/index.js";
import { SDKValidationError } from "../models/errors/sdkvalidationerror.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Patch segment
 *
 * @remarks
 * Update a segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](https://launchdarkly.com/docs/api#updates).
 *
 * ### Using semantic patches on a segment
 *
 * To make a semantic patch request, you must append `domain-model=launchdarkly.semanticpatch` to your `Content-Type` header. To learn more, read [Updates using semantic patch](https://launchdarkly.com/docs/api#updates-using-semantic-patch).
 *
 * The body of a semantic patch request for updating segments requires an `environmentKey` in addition to `instructions` and an optional `comment`. The body of the request takes the following properties:
 *
 * * `comment` (string): (Optional) A description of the update.
 * * `environmentKey` (string): (Required) The key of the LaunchDarkly environment.
 * * `instructions` (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a `kind` property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.
 *
 * ### Instructions
 *
 * Semantic patch requests support the following `kind` instructions for updating segments.
 *
 * <details>
 * <summary>Click to expand instructions for <strong>updating segment details and settings</strong></summary>
 *
 * #### addTags
 *
 * Adds tags to the segment.
 *
 * ##### Parameters
 *
 * - `values`: A list of tags to add.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addTags",
 *     "values": ["tag1", "tag2"]
 *   }]
 * }
 * ```
 *
 * #### removeTags
 *
 * Removes tags from the segment.
 *
 * ##### Parameters
 *
 * - `values`: A list of tags to remove.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeTags",
 *     "values": ["tag1", "tag2"]
 *   }]
 * }
 * ```
 *
 * #### updateName
 *
 * Updates the name of the segment.
 *
 * ##### Parameters
 *
 * - `value`: Name of the segment.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "updateName",
 *     "value": "Updated segment name"
 *   }]
 * }
 * ```
 *
 * </details>
 *
 * <details>
 * <summary>Click to expand instructions for <strong>updating segment individual targets</strong></summary>
 *
 * #### addExcludedTargets
 *
 * Adds context keys to the individual context targets excluded from the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.
 *
 * ##### Parameters
 *
 * - `contextKind`: The context kind the targets should be added to.
 * - `values`: List of keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addExcludedTargets",
 *     "contextKind": "org",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### addExcludedUsers
 *
 * Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addExcludedTargets` instead of this instruction.
 *
 * ##### Parameters
 *
 * - `values`: List of user keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addExcludedUsers",
 *     "values": [ "user-key-123abc", "user-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### addIncludedTargets
 *
 * Adds context keys to the individual context targets included in the segment for the specified `contextKind`. Returns an error if this causes the same context key to be both included and excluded.
 *
 * ##### Parameters
 *
 * - `contextKind`: The context kind the targets should be added to.
 * - `values`: List of keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addIncludedTargets",
 *     "contextKind": "org",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### addIncludedUsers
 *
 * Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use `addIncludedTargets` instead of this instruction.
 *
 * ##### Parameters
 *
 * - `values`: List of user keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addIncludedUsers",
 *     "values": [ "user-key-123abc", "user-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### removeExcludedTargets
 *
 * Removes context keys from the individual context targets excluded from the segment for the specified `contextKind`.
 *
 * ##### Parameters
 *
 * - `contextKind`: The context kind the targets should be removed from.
 * - `values`: List of keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeExcludedTargets",
 *     "contextKind": "org",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### removeExcludedUsers
 *
 * Removes user keys from the individual user targets excluded from the segment. If you are working with contexts, use `removeExcludedTargets` instead of this instruction.
 *
 * ##### Parameters
 *
 * - `values`: List of user keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeExcludedUsers",
 *     "values": [ "user-key-123abc", "user-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### removeIncludedTargets
 *
 * Removes context keys from the individual context targets included in the segment for the specified `contextKind`.
 *
 * ##### Parameters
 *
 * - `contextKind`: The context kind the targets should be removed from.
 * - `values`: List of keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeIncludedTargets",
 *     "contextKind": "org",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### removeIncludedUsers
 *
 * Removes user keys from the individual user targets included in the segment. If you are working with contexts, use `removeIncludedTargets` instead of this instruction.
 *
 * ##### Parameters
 *
 * - `values`: List of user keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeIncludedUsers",
 *     "values": [ "user-key-123abc", "user-key-456def" ]
 *   }]
 * }
 * ```
 *
 * </details>
 *
 * <details>
 * <summary>Click to expand instructions for <strong>updating segment targeting rules</strong></summary>
 *
 * #### addClauses
 *
 * Adds the given clauses to the rule indicated by `ruleId`.
 *
 * ##### Parameters
 *
 * - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, if not provided, defaults to `user`. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.
 * - `ruleId`: ID of a rule in the segment.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addClauses",
 *     "clauses": [
 *       {
 *         "attribute": "email",
 *         "negate": false,
 *         "op": "contains",
 *         "values": ["value1"]
 *       }
 *     ],
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29",
 *   }]
 * }
 * ```
 *
 * #### addRule
 *
 * Adds a new targeting rule to the segment. The rule may contain `clauses`.
 *
 * ##### Parameters
 *
 * - `clauses`: Array of clause objects, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, if not provided, defaults to `user`. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.
 * - `description`: A description of the rule.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addRule",
 *     "clauses": [
 *       {
 *         "attribute": "email",
 *         "op": "contains",
 *         "negate": false,
 *         "values": ["@launchdarkly.com"]
 *       }
 *     ],
 *     "description": "Targeting rule for LaunchDarkly employees",
 *   }]
 * }
 * ```
 *
 * #### addValuesToClause
 *
 * Adds `values` to the values of the clause that `ruleId` and `clauseId` indicate. Does not update the context kind, attribute, or operator.
 *
 * ##### Parameters
 *
 * - `ruleId`: ID of a rule in the segment.
 * - `clauseId`: ID of a clause in that rule.
 * - `values`: Array of strings, case sensitive.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addValuesToClause",
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29",
 *     "clauseId": "10a58772-3121-400f-846b-b8a04e8944ed",
 *     "values": ["beta_testers"]
 *   }]
 * }
 * ```
 *
 * #### removeClauses
 *
 * Removes the clauses specified by `clauseIds` from the rule indicated by `ruleId`.
 *
 * ##### Parameters
 *
 * - `ruleId`: ID of a rule in the segment.
 * - `clauseIds`: Array of IDs of clauses in the rule.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeClauses",
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29",
 *     "clauseIds": ["10a58772-3121-400f-846b-b8a04e8944ed", "36a461dc-235e-4b08-97b9-73ce9365873e"]
 *   }]
 * }
 * ```
 *
 * #### removeRule
 *
 * Removes the targeting rule specified by `ruleId`. Does nothing if the rule does not exist.
 *
 * ##### Parameters
 *
 * - `ruleId`: ID of a rule in the segment.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeRule",
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29"
 *   }]
 * }
 * ```
 *
 * #### removeValuesFromClause
 *
 * Removes `values` from the values of the clause indicated by `ruleId` and `clauseId`. Does not update the context kind, attribute, or operator.
 *
 * ##### Parameters
 *
 * - `ruleId`: ID of a rule in the segment.
 * - `clauseId`: ID of a clause in that rule.
 * - `values`: Array of strings, case sensitive.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeValuesFromClause",
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29",
 *     "clauseId": "10a58772-3121-400f-846b-b8a04e8944ed",
 *     "values": ["beta_testers"]
 *   }]
 * }
 * ```
 *
 * #### reorderRules
 *
 * Rearranges the rules to match the order given in `ruleIds`. Returns an error if `ruleIds` does not match the current set of rules in the segment.
 *
 * ##### Parameters
 *
 * - `ruleIds`: Array of IDs of all targeting rules in the segment.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "reorderRules",
 *     "ruleIds": ["a902ef4a-2faf-4eaf-88e1-ecc356708a29", "63c238d1-835d-435e-8f21-c8d5e40b2a3d"]
 *   }]
 * }
 * ```
 *
 * #### updateClause
 *
 * Replaces the clause indicated by `ruleId` and `clauseId` with `clause`.
 *
 * ##### Parameters
 *
 * - `ruleId`: ID of a rule in the segment.
 * - `clauseId`: ID of a clause in that rule.
 * - `clause`: New `clause` object, with `contextKind` (string), `attribute` (string), `op` (string), `negate` (boolean), and `values` (array of strings, numbers, or dates) properties. The `contextKind`, if not provided, defaults to `user`. The `contextKind`, `attribute`, and `values` are case sensitive. The `op` must be lower-case.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "updateClause",
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29",
 *     "clauseId": "10c7462a-2062-45ba-a8bb-dfb3de0f8af5",
 *     "clause": {
 *       "contextKind": "user",
 *       "attribute": "country",
 *       "op": "in",
 *       "negate": false,
 *       "values": ["Mexico", "Canada"]
 *     }
 *   }]
 * }
 * ```
 *
 * #### updateRuleDescription
 *
 * Updates the description of the segment targeting rule.
 *
 * ##### Parameters
 *
 * - `description`: The new human-readable description for this rule.
 * - `ruleId`: The ID of the rule. You can retrieve this by making a GET request for the segment.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "updateRuleDescription",
 *     "description": "New rule description",
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29"
 *   }]
 * }
 * ```
 *
 * #### updateRuleRolloutAndContextKind
 *
 * For a rule that includes a percentage of targets, updates the percentage and the context kind of the targets to include.
 *
 * ##### Parameters
 *
 * - `ruleId`: The ID of a targeting rule in the segment that includes a percentage of targets.
 * - `weight`: The weight, in thousandths of a percent (0-100000).
 * - `contextKind`: The context kind.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "reorderRules",
 *     "ruleId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29",
 *     "weight": "20000",
 *     "contextKind": "device"
 *   }]
 * }
 * ```
 *
 * </details>
 *
 * <details>
 * <summary>Click to expand instructions for <strong>working with Big Segments</strong></summary>
 *
 * A "big segment" is a segment that is either a synced segment, or a list-based segment with more than 15,000 entries that includes only one targeted context kind. LaunchDarkly uses different implementations for different types of segments so that all of your segments have good performance.
 *
 * The following semantic patch instructions apply only to these [larger list-based segments](https://launchdarkly.com/docs/home/flags/segments-create#create-larger-list-based-segments).
 *
 * #### addBigSegmentExcludedTargets
 *
 * For use with [larger list-based segments](https://launchdarkly.com/docs/home/flags/segments-create#create-larger-list-based-segments) ONLY. Adds context keys to the context targets excluded from the segment. Returns an error if this causes the same context key to be both included and excluded.
 *
 * ##### Parameters
 *
 * - `values`: List of context keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addBigSegmentExcludedTargets",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### addBigSegmentIncludedTargets
 *
 * For use with [larger list-based segments](https://launchdarkly.com/docs/home/flags/segments-create#create-larger-list-based-segments) ONLY. Adds context keys to the context targets included in the segment. Returns an error if this causes the same context key to be both included and excluded.
 *
 * ##### Parameters
 *
 * - `values`: List of context keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "addBigSegmentIncludedTargets",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### processBigSegmentImport
 *
 * For use with [larger list-based segments](https://launchdarkly.com/docs/home/flags/segments-create#create-larger-list-based-segments) ONLY. Processes a segment import.
 *
 * ##### Parameters
 *
 * - `importId`: The ID of the import. The import ID is returned in the `Location` header as part of the [Create big segment import](https://launchdarkly.com/docs/api/segments/create-big-segment-import) request.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "processBigSegmentImport",
 *     "importId": "a902ef4a-2faf-4eaf-88e1-ecc356708a29"
 *   }]
 * }
 * ```
 *
 * #### removeBigSegmentExcludedTargets
 *
 * For use with [larger list-based segments](https://launchdarkly.com/docs/home/flags/segments-create#create-larger-list-based-segments) ONLY. Removes context keys from the context targets excluded from the segment.
 *
 * ##### Parameters
 *
 * - `values`: List of context keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeBigSegmentExcludedTargets",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * #### removeBigSegmentIncludedTargets
 *
 * For use with [larger list-based segments](https://launchdarkly.com/docs/home/flags/segments-create#create-larger-list-based-segments) ONLY. Removes context keys from the context targets included in the segment.
 *
 * ##### Parameters
 *
 * - `values`: List of context keys.
 *
 * Here's an example:
 *
 * ```json
 * {
 *   "instructions": [{
 *     "kind": "removeBigSegmentIncludedTargets",
 *     "values": [ "org-key-123abc", "org-key-456def" ]
 *   }]
 * }
 * ```
 *
 * </details>
 *
 * ### Using JSON patches on a segment
 *
 * If you do not include the header described above, you can use a [JSON patch](https://launchdarkly.com/docs/api#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.
 *
 * For example, to update the description for a segment with a JSON patch, use the following request body:
 *
 * ```json
 * {
 *   "patch": [
 *     {
 *       "op": "replace",
 *       "path": "/description",
 *       "value": "new description"
 *     }
 *   ]
 * }
 * ```
 *
 * To update fields in the segment that are arrays, set the `path` to the name of the field and then append `/<array index>`. Use `/0` to add the new entry to the beginning of the array. Use `/-` to add the new entry to the end of the array.
 *
 * For example, to add a rule to a segment, use the following request body:
 *
 * ```json
 * {
 *   "patch":[
 *     {
 *       "op": "add",
 *       "path": "/rules/0",
 *       "value": {
 *         "clauses": [{ "contextKind": "user", "attribute": "email", "op": "endsWith", "values": [".edu"], "negate": false }]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * To add or remove targets from segments, we recommend using semantic patch. Semantic patch for segments includes specific instructions for adding and removing both included and excluded targets.
 */
export function segmentsPatch(
  client: LaunchDarklyCore,
  request: operations.PatchSegmentRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    components.UserSegment,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.StatusConflictErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >
> {
  return new APIPromise($do(
    client,
    request,
    options,
  ));
}

async function $do(
  client: LaunchDarklyCore,
  request: operations.PatchSegmentRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      components.UserSegment,
      | errors.InvalidRequestErrorRep
      | errors.UnauthorizedErrorRep
      | errors.ForbiddenErrorRep
      | errors.NotFoundErrorRep
      | errors.StatusConflictErrorRep
      | errors.RateLimitedErrorRep
      | APIError
      | SDKValidationError
      | UnexpectedClientError
      | InvalidRequestError
      | RequestAbortedError
      | RequestTimeoutError
      | ConnectionError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) => operations.PatchSegmentRequest$outboundSchema.parse(value),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = encodeJSON("body", payload.PatchWithComment, { explode: true });

  const pathParams = {
    environmentKey: encodeSimple("environmentKey", payload.environmentKey, {
      explode: false,
      charEncoding: "percent",
    }),
    projectKey: encodeSimple("projectKey", payload.projectKey, {
      explode: false,
      charEncoding: "percent",
    }),
    segmentKey: encodeSimple("segmentKey", payload.segmentKey, {
      explode: false,
      charEncoding: "percent",
    }),
  };

  const path = pathToFunc(
    "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}",
  )(pathParams);

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const secConfig = await extractSecurity(client._options.apiKey);
  const securityInput = secConfig == null ? {} : { apiKey: secConfig };
  const requestSecurity = resolveGlobalSecurity(securityInput);

  const context = {
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "patchSegment",
    oAuth2Scopes: [],

    resolvedSecurity: requestSecurity,

    securitySource: client._options.apiKey,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "PATCH",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: ["400", "401", "403", "404", "409", "429", "4XX", "5XX"],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const responseFields = {
    HttpMeta: { Response: response, Request: req },
  };

  const [result] = await M.match<
    components.UserSegment,
    | errors.InvalidRequestErrorRep
    | errors.UnauthorizedErrorRep
    | errors.ForbiddenErrorRep
    | errors.NotFoundErrorRep
    | errors.StatusConflictErrorRep
    | errors.RateLimitedErrorRep
    | APIError
    | SDKValidationError
    | UnexpectedClientError
    | InvalidRequestError
    | RequestAbortedError
    | RequestTimeoutError
    | ConnectionError
  >(
    M.json(200, components.UserSegment$inboundSchema),
    M.jsonErr(400, errors.InvalidRequestErrorRep$inboundSchema),
    M.jsonErr(401, errors.UnauthorizedErrorRep$inboundSchema),
    M.jsonErr(403, errors.ForbiddenErrorRep$inboundSchema),
    M.jsonErr(404, errors.NotFoundErrorRep$inboundSchema),
    M.jsonErr(409, errors.StatusConflictErrorRep$inboundSchema),
    M.jsonErr(429, errors.RateLimitedErrorRep$inboundSchema),
    M.fail("4XX"),
    M.fail("5XX"),
  )(response, { extraFields: responseFields });
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
